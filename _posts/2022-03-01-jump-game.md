---
layout: post
title: Jump Game Problem
date: 2022-03-01
Author: 麻瓜码农
categories: [leetcode]
tags: [Greedy, DP]
comments: true
toc: true
---

Leetcode刷题遇到[JumpGameII](https://leetcode.com/problems/jump-game-ii/) 这题，一开始想到用dp去找每个index的最远能到的index。 但是要用到两层循环。时间复杂度worst-> O(n^2)。 看了题解的Greedy方法还是没有完全理解，专门整理所有jump game的题目方便回忆。 

Jump Game 感觉是热门面试题。一定要理解透！！

## Jump Game
[JumpGame](https://leetcode.com/problems/jump-game)
给一个数组，元素对于从当前位置最远跳到多少个位置，返回是否可以到达最后一个元素。


###Solution 1: DP O(N^2)
第一反应是用dp，用一个一维数组记录当前index是否可以到达最后位置。 同时从后向前遍历数组，
dp[i] = dp[i + j] for j in (1, nums[i]), 只要一个为true则dp[i]为true。

时间复杂度分析: 最坏情况：只能直接从index = 0 跳到最后一个元素。外层循环n次，内层循环也是n次。
O(N^2);

Space Complexity：O(N)


    public boolean canJump(int[] nums) {
        
        boolean[] dp = new boolean[nums.length];
        Arrays.fill(dp, false);
        // O(N^2)
        for (int i = nums.length - 1; i >= 0; i--) {
            if (i + nums[i] >= nums.length - 1) {
                dp[i] = true;
                continue;
            }  
            for (int j = 1; j <= nums[i]; j++) {
                if (dp[i + j]) {
                    dp[i] = true;
                    break;
                }
            }
        }
        
        return dp[0];
    }

###Solution 2: Greedy O(N)

解析见JumpGameII Solution 2

Time Complexity: O(N), Space Complexity: O(1)

    public boolean canJump(int[] nums) {
        
        int max = 0;
        int currMax = 0;
        
        for (int i = 0; i < nums.length - 1; i++) {
            currMax = Math.max(currMax, i + nums[i]);
            if (i == max) {
                max = currMax;
            }
        }
        return max >= nums.length - 1;
    }



## Jump Game II
[JumpGameII](https://leetcode.com/problems/jump-game-ii)

Base on Jump Game, 找到到达last index的最小步数

### Solution 1：DP O(N^2)

时间复杂度分析: 最坏情况：只能直接从index = 0 跳到最后一个元素。外层循环n次，内层循环也是n次。
O(N^2);

Space Complexity：O(N)

    public int jump(int[] nums) {
        
        // dp[i] the min steps to last index 
        int[] dp = new int[nums.length];
        Arrays.fill(dp, nums.length);
        dp[nums.length - 1] = 0;
        for (int i = nums.length - 2; i >= 0; i--) {
            if (i + nums[i] >= nums.length - 1) {
                dp[i] = 1;
                continue;
            }
            for (int j = 1; j <= nums[i]; j++) {
                dp[i] = Math.min(dp[i], dp[i + j] + 1);
            }
        }
        return dp[0];
    }

### Solution 2 Greedy O(N)

for index i, the jump could at [i + 0, i + nums[i]]. we need to decide where we jump next.

![img.png](https://leetcode.com/problems/jump-game-ii/Figures/45/45-Page-3-new.png)
As shown in Figure, consider two people A and B, where A follows our greedy strategy and B follows the optimal solution. The number at each index defines the maximum jump distance. Let's assume that until this point, their decisions have been identical, and this is when the disagreement happens.

Algorithm:
Initialize three integer variables: jumps to count the number of jumps, currentJumpEnd to mark the end of the range that we can jump to, and farthest to mark the farthest place that we can reach. Set each variable to zero.

Time Complexity: O(N), Space Complexity: O(1)

    public int jump(int[] nums) {
        
        int maxIndex = 0;
        int currMax = 0;
        int step = 0;
        for (int i = 0; i < nums.length - 1; i++) {
            maxIndex = Math.max(maxIndex, i + nums[i]);
            if (i == currMax) {
                step++;
                currMax = maxIndex;
            }
        }
        return step;
    }

### Jump Game III

[JumpGameIII](https://leetcode.com/problems/jump-game-iii)

Given an array of non-negative integers arr, you are initially positioned at start index of the array. When you are at index i, you can jump to i + arr[i] or i - arr[i], check if you can reach to any index with value 0.

>Input: arr = [4,2,3,0,3,1,2], start = 5
Output: true
Explanation:
All possible ways to reach at index 3 with value 0 are:
index 5 -> index 4 -> index 1 -> index 3
index 5 -> index 6 -> index 4 -> index 1 -> index 3 
>

基本就是BFS或者DFS求解，唯一一点trick的地方在于如何标记visited的index。

DFS： recursion

Time complexity: O(N) since we will visit every index only once.

Space complexity: O(N) since it needs at most O(N) stacks for recursions.

    public boolean canReach(int[] arr, int start) {
        
        if (start < 0 || start >= arr.length || arr[start] < 0) {
            return false;
        }
        
        if (arr[start] == 0) {
            return true;
        }
        
        // mark the visited index !!!
        arr[start] = -arr[start]; -> 这里还是比较有意思的
        return canReach(arr, start - arr[start]) || canReach(arr, start + arr[start]);
    }

BFS： 

Time complexity: O(N) since we will visit every index at most once.

Space complexity : O(N), since it needs q to store next index. In fact, q would keep at most two levels of nodes. Since we got two children for each node, the traversal of this solution is a binary tree. The maximum number of nodes within a single level for a binary tree would be N/2, so the maximum length of q is O(N/2 + N/2)= O(N).

    public boolean canReach(int[] arr, int start) {
        
        Queue<Integer> queue = new LinkedList<>();
        queue.add(start);
        
        while (!queue.isEmpty()) {
            int currIndex = queue.poll();
            if (arr[currIndex] == 0) {
                return true;
            }
            if (arr[currIndex] > 0) {
                arr[currIndex] = -arr[currIndex];  ---> tricky 
                if (currIndex + arr[currIndex] >= 0 && currIndex + arr[currIndex] < arr.length) {
                    queue.add(currIndex + arr[currIndex]);
                }
                if (currIndex - arr[currIndex] >= 0 && currIndex - arr[currIndex] < arr.length) {
                    queue.add(currIndex - arr[currIndex]);
                }
            }
        }
        return false;
    }


### Jump Game IV 

[JumpGameIV](https://leetcode.com/problems/jump-game-iv)

这题非常有意思，也是III的follow up, BFS找到最短路径问题。

解法：BFS找最短路径，return 最短路径step的大小。 

1. 用List记录当前的layer, 
2. if currLayer is not empty 
3. find all next node for each node in currLayer, save them in next Layer
4. curr = next, step++
5. until find the target node. return step.

Time complexity: O(N) since we will visit every node at most once.

Space complexity: O(N) since it needs curs and nex to store nodes.

    public int minJumps(int[] arr) {
        
        int step = 0;
        HashMap<Integer, List<Integer>> map = new HashMap<>();
        
        for (int i = 0; i < arr.length; i++) {
            List<Integer> tmp = map.getOrDefault(arr[i], new LinkedList<>());
            tmp.add(i);
            map.put(arr[i], tmp);
        }
        
        List<Integer> curr = new LinkedList<>();
        HashSet<Integer> visited = new HashSet<>(); -> 用set记录已经走过的点
        curr.add(0);
        visited.add(0);
        
        while (!curr.isEmpty()) {
            List<Integer> next = new LinkedList<>();
            
            for (int idx : curr) {
                if (idx == arr.length - 1) {
                    return step;
                }
                if (idx + 1 >= 0 && idx + 1 < arr.length && !visited.contains(idx + 1)) {
                    visited.add(idx + 1);
                    next.add(idx + 1);
                }
                if (idx - 1 >= 0 && idx - 1 < arr.length && !visited.contains(idx - 1)) {
                    visited.add(idx - 1);
                    next.add(idx - 1);
                } 
                for (int index : map.get(arr[idx])) {
                    if (!visited.contains(index)) {
                        next.add(index);
                    }
                }
                map.get(arr[idx]).clear(); --> 这步非常有意思，很tricky的方法去避免重复
            }
            curr = next;
            step++;
        }
        
        return step;
    }


基础的BFS的问题在于如果step很多的话，最终的layer计算量会非常大。导致时间过长。

优化方法；BiDirection BFS -> 
1. 一个从begin 一个从end开始bfs
2. 每一次用layer.size()较小的一侧搜索
3. 直到两个layer的set中存在相同元素。return step

这种方法可以有效避免layer size过大的问题。可以作为面试题目的一种优化解法提一下，感觉能作为加分项