---
layout: post
title: Jump Game Problem
date: 2022-03-01
Author: 麻瓜码农
categories: [leetcode]
tags: [Greedy, DP]
comments: true
toc: true
---

Leetcode刷题遇到[JumpGameII](https://leetcode.com/problems/jump-game-ii/) 这题，一开始想到用dp去找每个index的最远能到的index。 但是要用到两层循环。时间复杂度worst-> O(n^2)。 看了题解的Greedy方法还是没有完全理解，专门整理所有jump game的题目方便回忆。 

Jump Game 感觉是热门面试题。一定要理解透！！

## Jump Game
[JumpGame](https://leetcode.com/problems/jump-game)
给一个数组，元素对于从当前位置最远跳到多少个位置，返回是否可以到达最后一个元素。


###Solution 1: DP O(N^2)
第一反应是用dp，用一个一维数组记录当前index是否可以到达最后位置。 同时从后向前遍历数组，
dp[i] = dp[i + j] for j in (1, nums[i]), 只要一个为true则dp[i]为true。

时间复杂度分析: 最坏情况：只能直接从index = 0 跳到最后一个元素。外层循环n次，内层循环也是n次。
O(N^2);

Space Complexity：O(N)


    public boolean canJump(int[] nums) {
        
        boolean[] dp = new boolean[nums.length];
        Arrays.fill(dp, false);
        // O(N^2)
        for (int i = nums.length - 1; i >= 0; i--) {
            if (i + nums[i] >= nums.length - 1) {
                dp[i] = true;
                continue;
            }  
            for (int j = 1; j <= nums[i]; j++) {
                if (dp[i + j]) {
                    dp[i] = true;
                    break;
                }
            }
        }
        
        return dp[0];
    }

###Solution 2: Greedy O(N)





## Jump Game II
[JumpGameII](https://leetcode.com/problems/jump-game-ii)

Base on Jump Game, 找到到达last index的最小步数

### Solution 1：DP O(N^2)

时间复杂度分析: 最坏情况：只能直接从index = 0 跳到最后一个元素。外层循环n次，内层循环也是n次。
O(N^2);

Space Complexity：O(N)
    public int jump(int[] nums) {
        
        // dp[i] the min steps to last index 
        int[] dp = new int[nums.length];
        Arrays.fill(dp, nums.length);
        dp[nums.length - 1] = 0;
        for (int i = nums.length - 2; i >= 0; i--) {
            if (i + nums[i] >= nums.length - 1) {
                dp[i] = 1;
                continue;
            }
            for (int j = 1; j <= nums[i]; j++) {
                dp[i] = Math.min(dp[i], dp[i + j] + 1);
            }
        }
        return dp[0];
    }

### Solution 2 Greedy O(N)

Time Complexity: O(N), Space Complexity: O(1)

    public int jump(int[] nums) {
        
        int maxIndex = 0;
        int currMax = 0;
        int step = 0;
        for (int i = 0; i < nums.length - 1; i++) {
            maxIndex = Math.max(maxIndex, i + nums[i]);
            if (i == currMax) {
                step++;
                currMax = maxIndex;
            }
        }
        return step;
    }